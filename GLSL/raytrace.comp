#version 430 core

layout( binding = 0, rgba32f ) uniform image2D frameBuffer;

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray10;
uniform vec3 ray01;
uniform vec3 ray11;

//
//	Defines
//
#define RECURSION_DEPTH 5
#define MAX_SCENE_BOUNDS 1E+10
#define EPSILON 0.0001
#define NUM_LIGHTS 1
#define NUM_BOXES 2
#define NUM_SPHERES 2

// Lighting
#define INTENSITY_AMBIENT 1.0;

// Constants
#define M_PI 3.14159265359

//	Parameters
#define BACKGROUND vec4( 0.89, 0.96, 1.0, 1.0 );

//
//	Lights
//

struct light {
	vec3 pos;
	float intensity;
};

const light lights[ NUM_LIGHTS ] = {
	{
		vec3( 0.0, 15.0, 0.0 ),
		1.5
	}
};

// 
//	Material
//

struct material {
	float k_ambient;
	float k_diffuse;
	float k_specular;
	int exp_surface;
};

//
// Geometry
//

struct box {
	vec3 min;
	vec3 max;
	vec4 color;
	material mat;
};

struct sphere {
	vec3 c;
	float r;
	vec4 color;
	material mat;
};

const box boxes[ NUM_BOXES ] = {
	// Floor
	{
		vec3( -5.0, -0.1, -5.0),
		vec3( 5.0, 0.0, 5.0 ),
		vec4( 0.247, 0.749, 0.247, 1.0 ),
		{
			1.0,
			0.5,
			0.5,
			32
		}
	},
	{
		vec3( -0.5, 0.0, -0.5),
		vec3( 0.5, 1.0, 0.5 ),
		vec4( 0.749, 0.247, 0.247, 1.0 ),
		{
			0.5,
			0.5,
			0.5,
			32
		}
	}
};

const sphere spheres[ NUM_SPHERES ] = {
	{
		vec3( -2.5, 2.0, -2.5 ),
		1.5,
		vec4( 0.247, 0.5, 0.749, 1.0 ),
		{
			1.0,
			1.0,
			1.0,
			32
		}
	},
	{
		vec3( 2.5, 1.0, 2.5 ),
		1.0,
		vec4( 0.137, 0.137, 0.137, 1.0 ),
		{
			1.0,
			1.0,
			1.0,
			32
		}
	}
};

//
//	HitInfo
//
const uint enum_box = 1;
const uint enum_sphere = 2;

struct hitinfo {
	uint type;
	float near;
	int i;
};

//
//	Functions
//

vec3 normalForBox( vec3 hit, const box b ){
	if( hit.x < b.min.x + EPSILON )
		return vec3( -1.0, 0.0, 0.0 );
	else if( hit.x > b.max.x - EPSILON )
		return vec3( 1.0, 0.0, 0.0 );
	else if( hit.y < b.min.y + EPSILON )
		return vec3( 0.0, -1.0, 0.0 );
	else if( hit.y > b.max.y - EPSILON )
		return vec3( 0.0, 1.0, 0.0 );
	else if( hit.z < b.min.z + EPSILON )
		return vec3( 0.0, 0.0, -1.0 );
	else
		return vec3( 0.0, 0.0, 1.0 );
}

vec2 intersectBox( vec3 origin, vec3 dir, const box b ){
	vec3 tMin = ( b.min - origin ) / dir;
	vec3 tMax = ( b.max - origin ) / dir;
	vec3 t1 = min( tMin, tMax );
	vec3 t2 = max( tMin, tMax );
	float tNear = max( max( t1.x, t1.y ), t1.z );
	float tFar = min( min( t2.x, t2.y ), t2.z );
	return vec2( tNear, tFar );
}

bool intersectBoxes( vec3 origin, vec3 dir, out hitinfo info ){
	float nearest = MAX_SCENE_BOUNDS;
	bool found = false;
	for( int i = 0 ; i < NUM_BOXES ; i++ ){
		vec2 lambda = intersectBox( origin, dir, boxes[ i ] );
		if( lambda.y > 0.0 && lambda.x < lambda.y && lambda.x < nearest ){
			info.type = enum_box;
			info.near = lambda.x;
			info.i = i;
			nearest = lambda.x;
			found = true;
		}
	}
	return found;
}

float intersectSphere( vec3 origin, vec3 dir, const sphere s ){
	vec3 rc = origin - s.c;
	float c = dot( rc, rc ) - ( s.r * s.r );
	float b = dot( dir, rc );
	float d = b * b - c;
	float t = -b - sqrt( abs( d ) );
	if( d < 0.0 || t < 0.0 )
		return -1.0;	// didn't hit
	return t;
}

bool intersectSpheres( vec3 origin, vec3 dir, out hitinfo info ){
	float nearest = MAX_SCENE_BOUNDS;
	bool found = false;
	for( int i = 0 ; i < NUM_SPHERES ; i++ ){
		float lambda = intersectSphere( origin, dir, spheres[ i ] );
		if( lambda > 0.0 && lambda < nearest ){
			info.type = enum_sphere;
			info.near = lambda;
			info.i = i;
			nearest = lambda;
			found = true;
		}
	}
	return found;
}

bool intersectObjects( vec3 origin, vec3 dir, out hitinfo info ){
	float nearest = MAX_SCENE_BOUNDS;
	bool found = false;

	hitinfo temp;
	if( intersectBoxes( origin, dir, temp ) ){
		nearest = temp.near;
		info = temp;
		found = true;
	}	
	if( intersectSpheres( origin, dir, temp ) ){
		if( nearest > temp.near ){
			nearest = temp.near;
			info = temp;
			found = true;
		}
	}
	return found;
}

bool intersectLight( vec3 origin, vec3 dir, hitinfo info ){

	hitinfo info_new;
	if( intersectObjects( origin, dir, info ) ){
		
		if( info.type == info_new.type && info.i == info_new.i )
			return true;
	}
	return false;
}

vec4 trace( vec3 origin, vec3 dir ){
	float nearest = MAX_SCENE_BOUNDS;
	hitinfo info;

	if( intersectObjects( origin, dir, info ) ){
		// Object info
		vec4 c;
		float k_ambient;
		float k_diffuse;
		float k_specular;
		int exp_surface;

		// Rays
		vec3 p = origin + info.near * dir;					// Hitpoint
		vec3 n;					// Normale
		vec3 r;					// Reflection
		vec3 t;					// Refraction


		if( info.type == enum_box ){

			box b = boxes[ info .i ];
			c = boxes[ info.i ].color;
			k_ambient = b.mat.k_ambient;
			k_diffuse = b.mat.k_diffuse;
			k_specular = b.mat.k_specular;
			exp_surface = b.mat.exp_surface;

			n = normalForBox( p, boxes[ info.i ] );

		} else if( info.type == enum_sphere ){

			sphere s = spheres[ info. i ];
			c = spheres[ info.i ].color;	
			k_ambient = s.mat.k_ambient;
			k_diffuse = s.mat.k_diffuse;
			k_specular = s.mat.k_specular;
			exp_surface = s.mat.exp_surface;

			n = normalize( p - spheres[ info.i ].c );
		}

		r = dir - 2 * dot( n, dir ) * n;
		// n = ...

		//
		//	Phong
		//
		float norm = ( exp_surface + 2.0 ) / 2 * M_PI;

		float i_in = 0.0;
		float i_a = 0.0;
		float i_d = 0.0;
		float i_s = 0.0;

		for( int i = 0 ; i < NUM_LIGHTS ; i++ ){
			
			light l = lights[ i ];
			if( intersectLight( l.pos, l.pos - p, info ) ){
				
				i_in += lights[ i ].intensity;
				i_a += k_ambient * INTENSITY_AMBIENT;
				i_d = i_in * k_diffuse * dot( n, normalize( lights[ i ].pos - p ) );
				i_s = i_in * k_specular * norm * pow( dot( r, origin ), exp_surface );
			}
		}

		float i_p = i_a + i_d + i_s;								// Final Phong
		vec4 c_p = c;

		//	Reflection
		//vec4 c_r = k_specular * trace( p, r );

		return c_p;
	}

	return BACKGROUND;
}

layout( local_size_x = 16, local_size_y = 16 ) in;

//
//	Main
//
void main( void ){
	ivec2 pix = ivec2( gl_GlobalInvocationID.xy );
	ivec2 size = imageSize( frameBuffer );
	if( pix.x >= size.x || pix.y >= size.y )											// Compute Shader Workgroups Size ( x | y ) ^ 2
		return;
	vec2 pos = ( vec2( pix ) + vec2( 0.5 ) ) / vec2( size );
	vec3 dir = mix( mix( ray00, ray01, pos.y ), mix( ray10, ray11, pos.y ), pos.x );
	vec4 color = trace( eye, normalize( dir ) );
	imageStore( frameBuffer, pix, color );
}