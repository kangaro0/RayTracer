#version 430 core

layout( binding = 0, rgba32f ) uniform image2D frameBuffer;

uniform float u_time;

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray10;
uniform vec3 ray01;
uniform vec3 ray11;

//
//	Defines
//
#define MAX_BOUNCES 3
#define MAX_SCENE_BOUNDS 1E+10
#define EPSILON 0.0001
#define NUM_LIGHTS 2
#define NUM_BOXES 7
#define NUM_SPHERES 3

// Lighting
#define INTENSITY_AMBIENT 0.8

// Constants
#define PI 3.14159265359

//	Parameters
#define BACKGROUND vec4( 0.89, 0.96, 1.0, 1.0 )

//
//	Lights
//

struct light {
	vec3 pos;
	float intensity;
};

const light lights[ NUM_LIGHTS ] = {
	// Sun
	{
		vec3( 0.0, sin( -u_time ) * 50, cos( -u_time ) * 50 ),
		0.8
	},
	/*
	{
		vec3( 15.0, 12.0, 0.0 ),
		0.2
	},
	*/
	{
		vec3( 7.5, 5.0, -4.5 ),
		0.2
	}
	//*/
};

// 
//	Material
//

struct m_phong {
	float k_ambient;
	float k_diffuse;
	float k_specular;
	int exp_surface;
};

struct material {
	m_phong p;
	float i_reflection;
	float i_refraction;
	float c_medium;
};

//
// Geometry
//

struct box {
	vec3 min;
	vec3 max;
	vec3 color;
	material mat;
};

struct sphere {
	vec3 c;
	float r;
	vec3 color;
	material mat;
};

const box boxes[ NUM_BOXES ] = {
	// Floor
	{
		vec3( -50.0, -0.1, -50.0),
		vec3( 50.0, 0.0, 50.0 ),
		vec3( 0.271, 0.267, 0.349 ),
		{
			// Phong
			{ 
				1.0,
				0.5,
				0.5,
				1
			},
			0.0,	// Reflection
			0.0,	// Refraction
			0.0		
		}
	},
	// Walls
	{
		vec3( -5.0, 0.0, -5.0 ),
		vec3( 7.5, 5.0, -4.9 ),
		vec3( 0.780, 0.631, 0.478 ),
		{
			{
				1.0,
				0.5,
				0.5,
				1
			},
			0.0,
			0.0,
			0.0
		}
	},
	{
		vec3( 7.5, 0.0, -4.9 ),
		vec3( 7.6, 5.0, 7.6 ),
		vec3( 0.271, 0.267, 0.349 ),
		{
			{ 
				1.0,
				0.5,
				0.5,
				1
			},
			0.0,
			0.0,
			0.0
		}
	},
	// Boxes
	{
		vec3( -0.5, 0.0, -0.5),
		vec3( 0.5, 1.0, 0.5 ),
		vec3( 0.749, 0.247, 0.247 ),
		{	
			{
				1.0,
				0.8,
				0.2,
				12
			},
			0.0,
			1.0,
			1.5
		}
	},
	{
		vec3( -0.8, 0.0, -1.5 ),
		vec3( -0.5, 0.3, -1.2 ),
		vec3( 0.886, 0.404, 0.141 ),
		{
			{
				1.0,
				0.8,
				0.2,
				12
			},
			0.9,
			0.0,
			0.0
		}
	},
	{
		vec3( -1.5, 0.0, -0.8 ),
		vec3( -1.2, 0.3, -0.5 ),
		vec3( 0.886, 0.404, 0.141 ),
		{
			{
				1.0,
				0.8,
				0.2,
				12
			},
			0.3,
			0.0,
			0.0
		}
	},
	{
		vec3( 0.8, 0.0, -1.1 ),
		vec3( 1.1, 0.3, -0.8 ),
		vec3( 0.463, 0.722, 1.0 ),
		{
			{
				1.0,
				0.0,
				0.8,
				16
			},
			0.2,
			0.0,
			0.0
		}
	}
};

const sphere spheres[ NUM_SPHERES ] = {
	{
		vec3( -2.5, 2.0, -2.5 ),
		1.5,
		vec3( 0.247, 0.5, 0.749 ),
		{
			{
				1.0,
				0.3,
				0.2,
				16
			},
			0.0,
			0.9,
			1.5
		}
	},
	{
		vec3( 2.5, 1.0, 1.5 ),
		1.0,
		vec3( 0.137, 0.137, 0.137 ),
		{
			{
				1.0,
				0.3,
				0.1,
				8
			},
			0.1,
			0.0,
			0.0
		}
	},
	{
		vec3( 3.0, 0.5, -1.0 ),
		0.5,
		vec3( 0.447, 0.310, 0.749 ),
		{
			{
				1.0,
				0.5,
				0.3,
				8
			},
			1.0,
			0.0,
			0.0
		}
	}
};

//
//	HitInfo
//
const uint enum_box = 1;
const uint enum_sphere = 2;

struct hitinfo {
	uint type;
	float near;
	int i;
};

//
//	Functions
//

vec3 normalForBox( vec3 hit, const box b ){
	if( hit.x < b.min.x + EPSILON )
		return vec3( -1.0, 0.0, 0.0 );
	else if( hit.x > b.max.x - EPSILON )
		return vec3( 1.0, 0.0, 0.0 );
	else if( hit.y < b.min.y + EPSILON )
		return vec3( 0.0, -1.0, 0.0 );
	else if( hit.y > b.max.y - EPSILON )
		return vec3( 0.0, 1.0, 0.0 );
	else if( hit.z < b.min.z + EPSILON )
		return vec3( 0.0, 0.0, -1.0 );
	else
		return vec3( 0.0, 0.0, 1.0 );
}

vec2 intersectBox( vec3 origin, vec3 dir, const box b ){
	vec3 tMin = ( b.min - origin ) / dir;
	vec3 tMax = ( b.max - origin ) / dir;
	vec3 t1 = min( tMin, tMax );
	vec3 t2 = max( tMin, tMax );
	float tNear = max( max( t1.x, t1.y ), t1.z );
	float tFar = min( min( t2.x, t2.y ), t2.z );
	return vec2( tNear, tFar );
}

bool intersectBoxes( vec3 origin, vec3 dir, out hitinfo info ){
	float nearest = MAX_SCENE_BOUNDS;
	bool found = false;
	for( int i = 0 ; i < NUM_BOXES ; i++ ){
		vec2 lambda = intersectBox( origin, dir, boxes[ i ] );
		if( lambda.y > 0.0 && lambda.x < lambda.y && lambda.x < nearest ){
			info.type = enum_box;
			info.near = lambda.x;
			info.i = i;
			nearest = lambda.x;
			found = true;
		}
	}
	return found;
}

float intersectSphere( vec3 origin, vec3 dir, const sphere s ){
	vec3 rc = origin - s.c;
	float c = dot( rc, rc ) - ( s.r * s.r );
	float b = dot( dir, rc );
	float d = b * b - c;
	float t = -b - sqrt( abs( d ) );
	if( d < 0.0 || t < 0.0 )
		return -1.0;	// didn't hit
	return t;
}

bool intersectSpheres( vec3 origin, vec3 dir, out hitinfo info ){
	float nearest = MAX_SCENE_BOUNDS;
	bool found = false;
	for( int i = 0 ; i < NUM_SPHERES ; i++ ){
		float lambda = intersectSphere( origin, dir, spheres[ i ] );
		if( lambda > 0.0 && lambda < nearest ){
			info.type = enum_sphere;
			info.near = lambda;
			info.i = i;
			nearest = lambda;
			found = true;
		}
	}
	return found;
}

bool intersectObjects( vec3 origin, vec3 dir, out hitinfo info ){
	float nearest = MAX_SCENE_BOUNDS;
	bool found = false;

	hitinfo temp;
	if( intersectBoxes( origin, dir, temp ) ){
		nearest = temp.near;
		info = temp;
		found = true;
	}	
	if( intersectSpheres( origin, dir, temp ) ){
		if( temp.near < nearest ){
			nearest = temp.near;
			info = temp;
			found = true;
		}
	}
	return found;
}

bool intersectLight( vec3 origin, vec3 dir, const hitinfo info ){
	
	hitinfo info_new;
	if( intersectObjects( origin, dir, info_new ) ){
		
		if( info.type == info_new.type && info.i == info_new.i )
			return true;
	}
	return false;
}

void swap( out float a, out float b ){
	float t = a;
	a = b;
	b = t;
}

vec3 reflect( vec3 v_in, vec3 n ){
	return normalize( v_in - 2 * dot( n, v_in ) * n );
}

///*
vec3 refract( vec3 v_in, vec3 n, float c_old, float c_new ){
	float cos_ai = dot( v_in, n );
	float angle_in = acos( cos_ai );
	float sin_ai = sin( angle_in );
	float ratio = c_old / c_new;
	return ratio * ( v_in + cos_ai * n ) - n * sqrt( 1 - pow( ratio, 2 ) * pow( sin_ai, 2 ) );
}
//*/
/*
vec3 refract( vec3 v_in, vec3 n, float c_old, float c_new ){
	float cosi = clamp( -1.0, 1.0, dot( v_in, n ) );
	
	if( cosi < 0 )
		cosi = -1.0 * cosi;
	else {
		swap( c_old, c_new );
		n = -1.0 * n;
	}
	float eta = c_old / c_new;
	float k = 1 - eta * eta * ( 1 - cosi * cosi );
	return k < 0 ? vec3(0.0) : eta * v_in + ( eta * cosi - sqrt( k ) ) * n;
}
//*/

float phong( light l, vec3 hit, vec3 n, m_phong p ){
	vec3 dir = normalize( hit - l.pos );							// Direction of light to hitpoint
	vec3 ld = -1.0 * dir;											// Direction of hitpoint to light
	vec3 r = normalize( 2 * dot( ld, n ) * n - ld );				// Direction of perfect reflection
	vec3 v = normalize( eye - hit );								// Direction to eye
	float norm = ( p.exp_surface + 2.0 ) / 2 * PI;					// Normalisation factor for specular reflection

	float i_d = p.k_diffuse * l.intensity * max( 0.0, dot( ld, n ) ); 
	float i_s = p.k_specular * l.intensity * norm * pow( max( 0.0, dot( r, v ) ), p.exp_surface );

	return i_d + i_s;
}

vec4 trace( vec3 origin, vec3 dir ){
	
	// Color
	vec3 color = vec3(1.0);
	float p_intensity = 0.0;
	float att = 1.0;

	// Medium
	float c_medium = 1.0;

	// State
	bool ray_inside = false;

	// Vectors
	vec3 p;												// Hitpoint
	vec3 n;												// Normale
	vec3 r;												// Reflection
	vec3 t;												// Refraction

	// Current Object info
	vec3 c;												// Object color
	material m;											// Material

	for( int b = 0 ; b < MAX_BOUNCES ; b++ ){

		if( att <= 0.1 )
			break;

		hitinfo info;
		if( intersectObjects( origin, dir, info ) ){
			
			// hitpoint
			p = origin + info.near * dir;

			// get data from object
			if( info.type == enum_box ){

				box b = boxes[ info .i ];						// Object that was hit
				c = b.color;						
				m = b.mat;			
				n = normalForBox( p, b );						// Normal at Hitpoint
				p += EPSILON;									// Distortion fix
				

			} else if( info.type == enum_sphere ){

				sphere s = spheres[ info. i ];
				c = s.color;	
				m = s.mat;
				n = normalize( p - s.c );

				if( ray_inside )
					p += n * EPSILON;
				else
					p -= n * EPSILON;
			}

			// calculate reflection & refraction
			r = reflect( dir, n );
			t = refract( dir, n, c_medium, ray_inside ? 1.0 : m.c_medium );

			// Phong
			p_intensity = m.p.k_ambient * INTENSITY_AMBIENT;
			for( int i = 0 ; i < NUM_LIGHTS ; i++ ){

				light l = lights[ i ];
				vec3 l_dir = normalize( p - l.pos );

				// object gets hit by light ray
				if( intersectLight( l.pos, l_dir, info ) ){

					p_intensity += phong( l, p, n, m.p );
				}
			}

			p_intensity *= float( NUM_LIGHTS ) / 2.0;
			
			vec3 c_p = c * p_intensity;

			color = ( b == 0 ? c_p : color + c_p * att );

		} else {
			
			color = ( b == 0 ? vec3( BACKGROUND ) : color + vec3( BACKGROUND ) );
			break;
		}

		// prepare for next cycle
		origin = p;
		if( m.i_reflection > 0.0 ){

			dir = r;
			att *= m.i_reflection * dot( dir, n );

		} else if( m.i_refraction > 0.0 ) {
			
			// total internal reflection
			if( t == vec3(0.0) ){
				dir = r;
				
			} else {
				dir = normalize( t );

				c_medium = ray_inside ? 1.0 : m.c_medium;

				ray_inside = !ray_inside;	
			}

			att *= m.i_refraction;

		} else {
			break;
		}
	}

	return vec4( color, 1.0 * p_intensity );
}

layout( local_size_x = 16, local_size_y = 16 ) in;

//
//	Main
//
void main( void ){
	ivec2 pix = ivec2( gl_GlobalInvocationID.xy );
	ivec2 size = imageSize( frameBuffer );
	if( pix.x >= size.x || pix.y >= size.y )											// Compute Shader Workgroups Size ( x | y ) ^ 2
		return;
	vec2 pos = ( vec2( pix ) + vec2( 0.5 ) ) / vec2( size );
	vec3 dir = mix( mix( ray00, ray01, pos.y ), mix( ray10, ray11, pos.y ), pos.x );
	vec4 color = trace( eye, normalize( dir ) );
	imageStore( frameBuffer, pix, color );
}